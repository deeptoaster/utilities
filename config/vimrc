set autoindent
set clipboard^=unnamed clipboard^=unnamedplus
set colorcolumn=80
if !has('nvim')
  set completeopt-=preview completeopt+=popup
endif
set conceallevel=2
set cursorline
set directory=/tmp
set display=lastline
set expandtab
set nofileignorecase
set foldmethod=syntax
set formatoptions=tcqj
set grepprg=grep\ -nrs\ $*\ /dev/null
set hlsearch
set incsearch
set nojoinspaces
if has('nvim')
  set nohidden
endif
set mouse=a
set number
set regexpengine=0
set sessionoptions-=blank sessionoptions-=buffers sessionoptions-=options
set showcmd
set shiftwidth=2
set tabstop=2
set viewoptions-=options
set wildmenu
filetype plugin indent on
syntax on
colorscheme sierra
highlight ColorColumn ctermbg=NONE
highlight CursorLine ctermbg=NONE
highlight CursorLineNr ctermbg=NONE
highlight LineNr ctermbg=NONE
highlight Normal ctermbg=NONE
highlight VertSplit ctermbg=NONE
highlight WinSeparator ctermbg=NONE
let $BASHOPTS = 'globstar'
let $BASH_ENV = '~/.bash_aliases'
let g:airline#extensions#branch#format = 2
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts = 1
let g:ale_completion_enabled = 1
let g:ale_fixers = {
  \ 'c': ['clang-format'],
  \ 'cpp': ['clang-format'],
  \ 'cuda': ['clang-format'],
  \ 'python': ['black'],
  \ 'tex': ['latexindent'],
  \ '*': ['prettier']
\ }
let g:ale_fix_on_save = 1
if has('popupwin') || has('nvim')
  let g:ale_hover_to_floating_preview = 1
endif
let g:ale_set_balloons = 1
let g:ale_virtualtext_cursor = 0
let g:ctrlp_custom_ignore =
    \ '\v[\/](\.catkin_tools|\.clangd\/index|\.git|\.venv|__pycache__|build|devel|dist|logs|node_modules)$'
let g:ctrlp_show_hidden = 1
let g:ctrlp_working_path_mode = 0
let g:DevIconsEnableFoldersOpenClose = 1
let g:NERDTreeGitStatusUseNerdFonts = 1
let g:NERDTreeShowHidden = 1
let g:vimtex_fold_enabled = 1
let g:vimtex_view_method = 'zathura'
packloadall
packadd vim-devicons
packadd nerdtree-git-plugin
packadd nerdtree
helptags ALL
function AddAlignment()
  let l:begin = search('\$\$', 'bcnW')
  let l:end = search('\$\$', 'nW')
  if l:begin != 0 && l:end != 0
    execute l:begin . 'substitute/\$\$/\\begin{align*}/'
    execute l:end . 'substitute/\$\$/\\end{align*}/'
    if l:end - l:begin >= 2
      execute (l:begin + 1) . ',' . (l:end - 1) .
          \ 'substitute/\v:?\=|\<\>|\\[gln]e|\\approx|\\in|\\propto|\\sim|\\subset(eq)?/\& \0/'
    endif
    if l:end - l:begin >= 3
      execute (l:begin + 1) . ',' . (l:end - 2) . 'substitute/$/ \\\\/'
    endif
  endif
endfunction
function s:AppendPandocMessage(bufnr, _channel, data, ...)
  call timer_stop(getbufvar(a:bufnr, 'pandoc_timer', 0))
  let l:pandoc_messages = getbufvar(a:bufnr, 'pandoc_messages')
  if has('nvim')
    if a:data !=# ['']
      if empty(l:pandoc_messages)
        call add(l:pandoc_messages, {'text': ''})
      endif
      let l:pandoc_messages[-1].text .= a:data[0]
      call extend(
        \ l:pandoc_messages,
        \ map(a:data[1:], {_index, message -> {'text': message}})
      \ )
    endif
  else
    call add(l:pandoc_messages, {'text': a:data})
  endif
  call setbufvar(
    \ a:bufnr,
    \ 'pandoc_timer',
    \ timer_start(600, function('s:EchoPandocMessages', [a:bufnr]))
  \ )
endfunction
function s:BufClean()
  for l:bufnr in range(1, bufnr('$'))
    if buflisted(l:bufnr) && bufwinnr(l:bufnr) == -1
      execute 'bdelete!' l:bufnr
    endif
  endfor
endfunction
function CodeActionDetailHover(data, menu)
  if !empty(a:menu)
    ALECodeAction
  elseif !empty(ale#util#FindItemAtCursor(bufnr())[1])
    ALEDetail
  else
    call HoverFunctionCall()
  endif
endfunction
function DrawerFind()
  let l:bufnr = bufnr()
  let l:winid = win_getid()
  if !g:NERDTree.IsOpen()
    call s:DrawerOpen()
  endif
  execute l:bufnr 'bufdo NERDTreeFind'
  if !empty(FugitiveGitDir(l:bufnr))
    wincmd j
    execute 'buffer' l:bufnr
    Gedit :
    normal zR
  endif
  call win_gotoid(l:winid)
endfunction
function s:DrawerOpen()
  let l:bufnr = bufnr()
  NERDTreeFocus
  if !empty(FugitiveGitDir(l:bufnr))
    execute 'belowright sbuffer' l:bufnr
    Gedit :
    normal zR
  endif
endfunction
function DrawerToggle()
  let l:winid = win_getid()
  if g:NERDTree.IsOpen()
    NERDTreeClose
    call s:FugitiveClose()
  else
    call s:DrawerOpen()
  endif
  call win_gotoid(l:winid)
endfunction
function s:EchoPandocMessages(bufnr, _timer)
  let l:pandoc_messages = getbufvar(a:bufnr, 'pandoc_messages')
  call setqflist(l:pandoc_messages)
  if !empty(l:pandoc_messages)
    call s:QuickfixOpen()
  endif
  call setbufvar(a:bufnr, 'pandoc_messages', [])
endfunction
function s:FugitiveClose()
  for l:bufnr in range(1, bufnr('$'))
    if getbufvar(l:bufnr, 'fugitive_type') ==# 'index'
      execute 'bdelete' l:bufnr
    endif
  endfor
endfunction
function GoToDefinition()
  try
    execute "normal! \<C-]>"
  catch
    ALEGoToDefinition
  endtry
endfunction
function GoToTerminal()
  for l:winnr in range(1, winnr('$'))
    if getbufvar(winbufnr(l:winnr), '&buftype') ==# 'terminal'
      execute l:winnr 'wincmd w'
      return
    endif
  endfor
endfunction
function s:Hover(line, column)
  let l:bufnr = bufnr()
  let b:ale_set_balloons = 0
  call timer_start(
    \ 600,
    \ {-> setbufvar(l:bufnr, 'ale_set_balloons', g:ale_set_balloons)}
  \ )
  call ale#hover#Show(
    \ l:bufnr,
    \ a:line,
    \ a:column,
    \ {'called_from_balloonexpr': v:true}
  \ )
endfunction
function HoverFunctionCall()
  let l:curpos = getpos('.')
  let [l:line, l:column] = searchpos('(', 'bcnW')
  if l:line == l:curpos[1] && l:column == l:curpos[2] - 1
    call s:Hover(l:line, l:column)
  else
    let &operatorfunc = function('s:HoverOperator', [winsaveview()])
    normal g@[(
  endif
endfunction
function s:HoverOneBack()
  if !empty(v:completed_item)
    let l:curpos = getpos('.')
    call s:Hover(l:curpos[1], l:curpos[2] - 1)
  endif
endfunction
function s:HoverOperator(view, type)
  call winrestview(a:view)
  let l:operatorpos = getpos("'[")
  call s:Hover(l:operatorpos[1], l:operatorpos[2])
endfunction
function s:Persist()
  if !empty(v:this_session) && !exists('g:SessionLoad')
    silent! execute 'mksession!' v:this_session
  endif
endfunction
function s:PersistAndCloseTerminals()
  if !empty(v:this_session) && empty(filter(range(1, bufnr('$')), {
    \ _index, bufnr ->
        \ getbufvar(bufnr, '&modified') &&
        \ getbufvar(bufnr, '&buftype') !=# 'terminal'
  \ }))
    call s:FugitiveClose()
    execute 'mksession!' v:this_session
    sleep 100m
    for l:bufnr in range(1, bufnr('$'))
      if getbufvar(l:bufnr, '&buftype') ==# 'terminal'
        execute 'bdelete!' l:bufnr
      endif
    endfor
  endif
endfunction
function QuickFixDifferentFile(operator)
  let l:qflist = getqflist({'id': 0, 'idx': 0, 'items': [], 'size': 0})
  let l:current = l:qflist.idx - 1
  let l:bufnr = l:qflist.items[l:current].bufnr
  for l:delta in range(1, l:qflist.size - 1)
    let l:other =
        \ (a:operator(l:current, l:delta) + l:qflist.size) % l:qflist.size
    if l:qflist.items[l:other].bufnr != l:bufnr
      execute 'cc' l:other + 1
      return
    endif
  endfor
endfunction
function s:QuickfixOpen()
  let l:winid = win_getid()
  cclose
  wincmd b
  wincmd v
  copen
  wincmd k
  quit
  call win_gotoid(l:winid)
endfunction
function QuickfixToggle()
  for l:winnr in range(1, winnr('$'))
    if getbufvar(winbufnr(l:winnr), '&buftype') ==# 'quickfix'
      cclose
      return
    endif
  endfor
  call s:QuickfixOpen()
endfunction
function s:RestoreLayout()
  call timer_stop(get(s:, 'terminals_timer', 0))
  let s:terminals_timer = timer_start(200, function('s:ReopenTerminals'))
  call s:FugitiveClose()
endfunction
function s:ReopenTerminals(_timer)
  let l:winid = win_getid()
  for l:bufnr in range(1, bufnr('$'))
    if getbufvar(l:bufnr, '&buftype') ==# 'terminal' ||
        \ bufname(l:bufnr)[0:6] ==# 'term://' && bufwinnr(l:bufnr) != -1
      execute bufwinnr(l:bufnr) 'wincmd w'
      if has('nvim')
        terminal
      else
        enew!
        terminal ++curwin
      endif
    endif
  endfor
  call win_gotoid(l:winid)
  call s:BufClean()
endfunction
function TogglePandocWorker()
  if get(b:, 'pandoc_job', v:null) is v:null
    let l:bufnr = bufnr()
    let l:source = expand('%:t')
    let l:target = '/tmp/' . fnamemodify(l:source, ':r') . '.pdf'
    let l:pandoc_command =
        \ 'inwm ' . l:source . ' pandoc -o ' . l:target . ' ' . l:source
    let l:zathura_command =
        \ 'inotifywait --event modify --quiet ' . l:target . ' && zathura ' .
        \ l:target
    let b:pandoc_messages = []
    call system('touch ' . l:target)
    if has('nvim')
      let b:pandoc_job = jobstart(
        \ l:pandoc_command,
        \ {
          \ 'cwd': expand('%:h'),
          \ 'on_stderr': function('s:AppendPandocMessage', [l:bufnr])
        \ }
      \ )
      let b:zathura_job = jobstart(l:zathura_command)
    else
      let b:pandoc_job = job_start(
        \ ['bash', '-c', l:pandoc_command],
        \ {
          \ 'cwd': expand('%:h'),
          \ 'err_cb': function('s:AppendPandocMessage', [l:bufnr])
        \ }
      \ )
      let b:zathura_job = job_start(['bash', '-c', l:zathura_command])
    endif
    let b:ale_fix_on_save = 0
    call timer_start(200, function('execute', [l:bufnr . 'bufdo write']))
  else
    if has('nvim')
      call jobstop(b:pandoc_job)
      call jobstop(b:zathura_job)
    else
      call job_stop(b:pandoc_job)
      call job_stop(b:zathura_job)
    endif
    let b:pandoc_job = v:null
    unlet b:ale_fix_on_save
    cclose
  endif
endfunction
augroup squiffles
  autocmd BufEnter * call s:Persist()
  autocmd CompleteDone * call s:HoverOneBack()
  autocmd ExitPre * call s:PersistAndCloseTerminals()
  autocmd FileType markdown noremap <buffer> <Leader>ll :call TogglePandocWorker()<CR>
  autocmd FileType php setlocal foldmethod=indent
  autocmd FileType python setlocal foldmethod=indent
  autocmd SessionLoadPost * call s:RestoreLayout()
  if has('nvim')
    autocmd TermOpen * setlocal nonumber
  endif
augroup end
command BC call s:BufClean()
cabbrev bc BC
cabbrev ccc CtrlPClearAllCaches
command GLAG Git log --all --date-order --decorate --graph
cabbrev glag GLAG
if has('nvim')
  cabbrev terminal split \| terminal
endif
noremap <C-@> :call ale#codefix#Execute(mode() ==# 'v' \|\| mode() ==# "\<lt>C-V>", function('CodeActionDetailHover'))<CR>
inoremap <C-@> <C-\><C-O>:call HoverFunctionCall()<CR>
noremap <C-LeftMouse> <LeftMouse>:call GoToDefinition()<CR>
if has('nvim')
  noremap <C-Space> :call ale#codefix#Execute(mode() ==# 'v' \|\| mode() ==# "\<lt>C-V>", function('CodeActionDetailHover'))<CR>
  inoremap <C-Space> <C-\><C-O>:call HoverFunctionCall()<CR>
  tnoremap <C-W> <C-\><C-N><C-W>
endif
tmap <C-W>: <C-\><C-N>:vertical terminal<CR><C-\><C-N>i
noremap <C-W>; :call GoToTerminal()<CR><C-\><C-N>i<Esc>a
noremap <C-]> :call GoToDefinition()<CR>
noremap <Leader>f :call DrawerFind()<CR>
noremap <Leader>l$ :call AddAlignment()<CR>
noremap <Leader>q :noautocmd call QuickfixToggle()<CR>
noremap <Leader>t :call DrawerToggle()<CR>
noremap [l :try <Bar> lprev <Bar> catch <Bar> try <Bar> llast <Bar> catch <Bar> ALEPreviousWrap <Bar> endtry <Bar> endtry<CR>
noremap ]l :try <Bar> lnext <Bar> catch <Bar> try <Bar> lfirst <Bar> catch <Bar> ALENextWrap <Bar> endtry <Bar> endtry<CR>
noremap [Q :call QuickFixDifferentFile({a, b -> a - b})<CR>
noremap ]Q :call QuickFixDifferentFile({a, b -> a + b})<CR>
noremap [q :try <Bar> cprev <Bar> catch <Bar> clast <Bar> endtry<CR>
noremap ]q :try <Bar> cnext <Bar> catch <Bar> cfirst <Bar> endtry<CR>
noremap Y y$
noremap y% :let @* = @% <Bar> let @+ = @%<CR>
