set autoindent
set clipboard^=unnamed clipboard^=unnamedplus
set colorcolumn=80
set completeopt-=preview completeopt+=popup
set cursorline
set directory=/tmp
set display=lastline
set expandtab
set nofileignorecase
set foldmethod=syntax
set formatoptions=tcqj
set grepprg=grep\ -ns\ $*\ /dev/null
set hlsearch
set incsearch
set nojoinspaces
set mouse=a
set number
set regexpengine=0
set sessionoptions-=blank sessionoptions-=buffers sessionoptions-=options
set showcmd
if !executable('zsh')
  set shell=bash\ -O\ globstar
endif
set shiftwidth=2
set tabstop=2
set viewoptions-=options
set wildmenu
filetype plugin indent on
syntax on
colorscheme sierra
highlight Normal ctermbg=NONE
let $BASH_ENV = '~/.bash_aliases'
let g:airline#extensions#branch#format = 2
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts = 1
let g:ale_completion_enabled = 1
let g:ale_fixers = {
  \ 'c': ['clang-format'],
  \ 'cpp': ['clang-format'],
  \ 'cuda': ['clang-format'],
  \ 'python': ['black'],
  \ '*': ['prettier']
\ }
let g:ale_fix_on_save = 1
if has('popupwin')
  let g:ale_hover_to_floating_preview = 1
endif
let g:ale_virtualtext_cursor = 1
let g:ctrlp_custom_ignore =
    \ '\v[\/](\.catkin_tools|\.clangd\/index|\.git|__pycache__|build|devel|dist|logs|node_modules)$'
let g:ctrlp_show_hidden = 1
let g:ctrlp_working_path_mode = 0
let g:DevIconsEnableFoldersOpenClose = 1
let g:NERDTreeGitStatusUseNerdFonts = 1
let g:NERDTreeShowHidden = 1
packloadall
packadd CtrlP
packadd ale
packadd vim-devicons
packadd nerdtree-git-plugin
packadd nerdtree
packadd vim-surround
function s:BufClean()
  for l:bufnr in range(1, bufnr('$'))
    if buflisted(l:bufnr) && !bufloaded(l:bufnr)
      execute 'bdelete' l:bufnr
    endif
  endfor
endfunction
function CodeActionDetailHover(data, menu)
  if !empty(a:menu)
    ALECodeAction
  elseif !empty(ale#util#FindItemAtCursor(bufnr())[1])
    ALEDetail
  else
    call HoverFunctionCall()
  endif
endfunction
function s:FugitiveClose()
  for l:bufnr in range(1, bufnr('$'))
    if getbufvar(l:bufnr, 'fugitive_type') ==# 'index'
      execute 'bdelete' l:bufnr
    endif
  endfor
endfunction
function GoToDefinition()
  try
    execute "normal! \<C-]>"
  catch
    ALEGoToDefinition
  endtry
endfunction
function GoToTerminal()
  for l:winnr in range(1, winnr('$'))
    if getbufvar(winbufnr(l:winnr), '&buftype') ==# 'terminal'
      execute l:winnr 'wincmd w'
      return
    endif
  endfor
endfunction
function HoverFunctionCall()
  let l:curline = getpos('.')[1]
  let [l:line, l:column] = searchpos('(', 'bcn')
  if l:line == l:curline
    call ale#hover#Show(
      \ bufnr(),
      \ l:line,
      \ l:column,
      \ { 'called_from_balloonexpr': v:true }
    \ )
  else
    ALEHover
  endif
endfunction
function s:HoverOneBack()
  if !empty(v:completed_item)
    let l:curpos = getpos('.')
    call ale#hover#Show(
      \ bufnr(),
      \ l:curpos[1],
      \ l:curpos[2] - 1,
      \ { 'called_from_balloonexpr': v:true }
    \ )
  endif
endfunction
function NERDTreeFugitiveFind()
  let l:bufnr = bufnr()
  if !g:NERDTree.IsOpen()
    call NERDTreeFugitiveToggle()
  endif
  execute l:bufnr 'bufdo NERDTreeFind'
  if !empty(FugitiveGitDir(l:bufnr))
    wincmd j
    execute 'buffer' l:bufnr
    Gedit :
    normal zR
  endif
endfunction
function NERDTreeFugitiveToggle()
  let l:bufnr = bufnr()
  if g:NERDTree.IsOpen()
    NERDTreeClose
    call s:FugitiveClose()
  else
    NERDTreeFocus
    if !empty(FugitiveGitDir(l:bufnr))
      execute 'belowright sbuffer' l:bufnr
      Gedit :
      normal zR
    endif
  endif
endfunction
function s:Persist()
  if !empty(v:this_session) && !exists('g:SessionLoad')
    execute 'mksession!' v:this_session
  endif
endfunction
function s:PersistWithoutTerminals()
  if !empty(v:this_session) && empty(filter(range(1, bufnr('$')), {
    \ idx, val ->
        \ getbufvar(val, '&modified') &&
        \ getbufvar(val, '&buftype') !=# 'terminal'
  \ }))
    call s:FugitiveClose()
    execute 'mksession!' v:this_session
    sleep 100m
    for l:bufnr in range(1, bufnr('$'))
      if getbufvar(l:bufnr, '&buftype') ==# 'terminal'
        execute 'bdelete!' l:bufnr
      endif
    endfor
  endif
endfunction
augroup squiffles
  autocmd BufEnter * call s:Persist()
  autocmd ExitPre * call s:PersistWithoutTerminals()
  autocmd CompleteDone * call s:HoverOneBack()
augroup end
command BC call s:BufClean()
cabbrev bc BC
command GLAG Git log --all --decorate --graph
cabbrev glag GLAG
noremap <C-@> :call ale#codefix#Execute(mode() ==# 'v' \|\| mode() ==# "\<lt>C-V>", function('CodeActionDetailHover'))<CR>
inoremap <C-@> <C-\><C-O>:call HoverFunctionCall()<CR>
noremap <C-LeftMouse> <LeftMouse>:call GoToDefinition()<CR>
noremap <C-]> :call GoToDefinition()<CR>
noremap <Leader>c :call GoToTerminal()<CR>
noremap <Leader>f :call NERDTreeFugitiveFind()<CR>
noremap <Leader>t :call NERDTreeFugitiveToggle()<CR>
noremap [l :try <Bar> lprev <Bar> catch <Bar> try <Bar> llast <Bar> catch <Bar> ALEPreviousWrap <Bar> endtry <Bar> endtry<CR>
noremap ]l :try <Bar> lnext <Bar> catch <Bar> try <Bar> lfirst <Bar> catch <Bar> ALENextWrap <Bar> endtry <Bar> endtry<CR>
noremap [q :try <Bar> cprev <Bar> catch <Bar> clast <Bar> endtry<CR>
noremap ]q :try <Bar> cnext <Bar> catch <Bar> cfirst <Bar> endtry<CR>
noremap Y y$
